#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>

struct Args {
	int a;
	const char* b;
};

void mappedFunction(void* pArgs) {
    typedef void __cdecl _print(int, const char*);
    Args* args = (Args*)pArgs;
	_print* print = (_print*)0x1B1000;
    print(args->a, args->b);
}

void markerFunction() { // Mark the end of the location of 'mappedFunction'
    return;
}

HANDLE getProcessHandle(const char* windowName) {
	HWND hwnd = FindWindowA(NULL, windowName);
	if (!hwnd) {
		std::cout << "Couldn't find " << windowName << "." << std::endl;
		return 0;
	}

	DWORD processID;
	HANDLE handle;

	GetWindowThreadProcessId(hwnd, &processID);
	handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);

	if (!processID || !handle) {
		std::cout << "Couldn't attach to " << windowName << "." << std::endl;
		return 0;
	};

	return handle;
}

void* createCharPointerString(HANDLE handle, const char* string) {
	void* stringMemory = VirtualAllocEx(handle, 0, strlen(string), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!stringMemory) {
		std::cout << "Couldn't allocate memory for char pointer." << std::endl;
		return 0;
	}

	if (!WriteProcessMemory(handle, stringMemory, string, strlen(string), 0)) {
		std::cout << "Couldn't to write to memory." << std::endl;
		return 0;
	}

	return stringMemory;
}

int main() {
	HANDLE handle = getProcessHandle("Memory Editor");

	if (!handle) {
		return 0;
	}

	const char* stringMemory = (const char*)createCharPointerString(handle, "String!");
	
	Args args = { 20, stringMemory };

	uintptr_t funcSize = (uintptr_t)markerFunction - (uintptr_t)mappedFunction;
	uintptr_t funcAndArgsSize = funcSize + sizeof(args);

	void* functionAndArgsMemory = VirtualAllocEx(handle, 0, funcAndArgsSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!functionAndArgsMemory) {
		std::cout << "Couldn't allocate memory for arguments." << std::endl;
		return 0;
	}

	void* argsMemory = (void*)((uintptr_t)functionAndArgsMemory + funcSize);

	if (!WriteProcessMemory(handle, functionAndArgsMemory, mappedFunction, funcSize, 0) || !WriteProcessMemory(handle, argsMemory, &args, sizeof(args), 0)) {
		std::cout << "Couldn't write function and/or arguments." << std::endl;
		return 0;
	}

	HANDLE hThread = CreateRemoteThread(handle, 0, 0, (LPTHREAD_START_ROUTINE)functionAndArgsMemory, argsMemory, 0, 0);
	if (!hThread) {
		std::cout << "Failed to create thread." << std::endl;
		return 0;
	}
	WaitForSingleObject(hThread, INFINITE);

	VirtualFreeEx(handle, functionAndArgsMemory, funcAndArgsSize, MEM_RELEASE);
	CloseHandle(hThread);
}